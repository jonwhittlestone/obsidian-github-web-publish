/**
 * Activity Log - Writes publish operations to a markdown log file
 *
 * Creates a human-readable log file (_publish-log.md) in each site folder
 * that tracks all publish/unpublish operations.
 */

import type { Vault } from 'obsidian';

/** Log entry types */
export type LogStatus =
	| 'published'
	| 'queued'
	| 'unpublished'
	| 'withdrawn'
	| 'failed'
	| 'validation'
	| 'warning'
	| 'retry';

/** Status icons for each log type */
const STATUS_ICONS: Record<LogStatus, string> = {
	published: '‚úÖ',
	queued: '‚è≥',
	unpublished: 'üóëÔ∏è',
	withdrawn: '‚Ü©Ô∏è',
	failed: '‚ùå',
	validation: 'üìã',
	warning: '‚ö†Ô∏è',
	retry: 'üîÑ',
};

/** Status labels for each log type */
const STATUS_LABELS: Record<LogStatus, string> = {
	published: 'Published',
	queued: 'Queued for scheduled publish',
	unpublished: 'Unpublished',
	withdrawn: 'Withdrawn',
	failed: 'Failed',
	validation: 'Validation failed',
	warning: 'Warning',
	retry: 'Retry',
};

/** A single log entry */
export interface LogEntry {
	status: LogStatus;
	postTitle: string;
	filename: string;
	prNumber?: number;
	prUrl?: string;
	liveUrl?: string;
	error?: string;
	details?: string;
}

/**
 * Activity Log writer
 */
export class ActivityLog {
	private vault: Vault;
	private sitePath: string;
	private logPath: string;

	constructor(vault: Vault, sitePath: string) {
		this.vault = vault;
		this.sitePath = sitePath;
		this.logPath = `${sitePath}/_publish-log.md`;
	}

	/**
	 * Add an entry to the log
	 */
	async log(entry: LogEntry): Promise<void> {
		const now = new Date();
		const time = this.formatTime(now);
		const date = this.formatDate(now);

		const entryText = this.formatEntry(entry, time);
		let content = await this.getOrCreateLog();

		// Find or create today's date section
		const dateHeader = `## ${date}`;
		const dateIndex = content.indexOf(dateHeader);

		if (dateIndex === -1) {
			// Add new date section after the header
			const headerEnd = content.indexOf('---\n\n') + 5;
			content = content.slice(0, headerEnd) + `\n${dateHeader}\n\n${entryText}\n` + content.slice(headerEnd);
		} else {
			// Insert entry after the date header
			const insertPoint = dateIndex + dateHeader.length + 1;
			content = content.slice(0, insertPoint) + `\n${entryText}\n` + content.slice(insertPoint);
		}

		await this.writeLog(content);
	}

	/**
	 * Get the log file content, or create it if it doesn't exist
	 */
	private async getOrCreateLog(): Promise<string> {
		const file = this.vault.getAbstractFileByPath(this.logPath);

		if (file) {
			return await this.vault.read(file as import('obsidian').TFile);
		}

		// Create new log file
		const header = `# Publishing Activity Log

> Auto-generated by GitHub Web Publish plugin.
> This file tracks all publish/unpublish operations.

## Required Frontmatter

Posts must include valid frontmatter to be published. Example:

\`\`\`yaml
---
title: My Post Title
layout: post
description: A brief description of the post
tags:
  - tag1
  - tag2
categories:
  - category1
date: 2026-01-15
---
\`\`\`

**Required fields:**
- \`title\` - The post title (max 200 characters)

**Optional fields:**
- \`layout\` - Page layout (post, page, or default)
- \`description\` - Brief description (max 500 characters)
- \`tags\` - List of tags
- \`categories\` - List of categories
- \`date\` - Publication date (YYYY-MM-DD)
- \`image\` - Featured image path
- \`author\` - Author name
- \`hide\` - Hide from listings (true/false)
- \`toc\` - Show table of contents (true/false)
- \`comments\` - Enable comments (true/false)

---

`;
		await this.vault.create(this.logPath, header);
		return header;
	}

	/**
	 * Write content to the log file
	 */
	private async writeLog(content: string): Promise<void> {
		const file = this.vault.getAbstractFileByPath(this.logPath);
		if (file) {
			await this.vault.modify(file as import('obsidian').TFile, content);
		}
	}

	/**
	 * Format a log entry as markdown
	 */
	private formatEntry(entry: LogEntry, time: string): string {
		const icon = STATUS_ICONS[entry.status];
		const label = STATUS_LABELS[entry.status];

		let text = `### ${time} - ${icon} ${label}\n`;
		text += `- **Post**: ${entry.postTitle}\n`;
		text += `- **File**: \`${entry.filename}\`\n`;

		if (entry.liveUrl) {
			text += `- **Live**: [View post](${entry.liveUrl})\n`;
		}

		if (entry.prNumber) {
			if (entry.prUrl) {
				text += `- **PR**: [#${entry.prNumber}](${entry.prUrl})\n`;
			} else {
				text += `- **PR**: #${entry.prNumber}\n`;
			}
		}

		if (entry.error) {
			text += `- **Error**: ${entry.error}\n`;
		}

		if (entry.details) {
			text += `- **Details**: ${entry.details}\n`;
		}

		return text;
	}

	/**
	 * Format time as HH:mm
	 */
	private formatTime(date: Date): string {
		return date.toLocaleTimeString('en-GB', {
			hour: '2-digit',
			minute: '2-digit',
			hour12: false,
		});
	}

	/**
	 * Format date as YYYY-MM-DD
	 */
	private formatDate(date: Date): string {
		const year = date.getFullYear();
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const day = String(date.getDate()).padStart(2, '0');
		return `${year}-${month}-${day}`;
	}
}
